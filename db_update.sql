-- Enable RLS
alter default privileges in schema public grant all on tables to postgres, service_role;

-- Visits Table
create table if not exists visits (
  id bigint generated by default as identity primary key,
  store_id bigint references stores(id) on delete cascade,
  visit_date text not null, -- Storing as Persian date string YYYY/MM/DD
  visit_time text, -- HH:MM
  note text,
  status text default 'pending', -- pending, done
  user_id uuid references auth.users not null default auth.uid(),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table visits enable row level security;

-- Policies (Drop first to avoid errors on rerun if using specific migration tool, but raw SQL in Supabase usually handles create if not exists or errors.
-- Since we can't do CREATE POLICY IF NOT EXISTS easily without DO block in standard Postgres < 9.x style or specific syntax,
-- users usually run this once. If they run it again, it might error on policy exists.
-- Let's make it robust using DO block if possible, or just accept that "relation already exists" is handled for table,
-- but policy conflict might happen.
-- For simplicity in Supabase SQL editor which runs transactionally usually:
-- We'll just provide the standard create statements. If they fail, user sees why.
-- But to be nicer:
drop policy if exists "Users can view their own visits" on visits;
drop policy if exists "Users can insert their own visits" on visits;
drop policy if exists "Users can update their own visits" on visits;
drop policy if exists "Users can delete their own visits" on visits;

create policy "Users can view their own visits"
  on visits for select
  using (auth.uid() = user_id);

create policy "Users can insert their own visits"
  on visits for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own visits"
  on visits for update
  using (auth.uid() = user_id);

create policy "Users can delete their own visits"
  on visits for delete
  using (auth.uid() = user_id);
